---
type: page
title: The Run Command and Function
listed: true
slug: the-run-command-and-function
description: 
index_title: The Run Command and Function
hidden: 
keywords: 
tags: 
---
# Program Execution Utilities

This section details the functions responsible for orchestrating the execution of code within the language, from handling top-level `RUN` commands to the core process of tokenization, parsing, and interpretation.

## `run(fn, text)`

**Purpose:** This is the top-level entry point for executing program text, primarily handling `RUN` commands and managing code segments, especially those involving `PROCEDURE`s (user-defined functions). It processes the input text into executable units and dispatches them to `run_program`.

**Important Note:** This function *does not* perform the actual tokenizing, parsing, or interpreting itself. It acts as a pre-processor and orchestrator, preparing the text for `run_program`.

**Parameters:**
* `fn`: A string representing the filename or source identifier (e.g., `<stdin>` for interactive input).
* `text`: The string containing the code to be executed.

**Explanation:**

```python
program_text = ""
proc_flag = False
if text.strip() == "":
    return

# Create tokens just for the sake of figuring out wheter we're dealing with a RUN command or a procedure
tokens = generate_tokens('<stdin>', text)
if str(tokens[0]) == "IDENTIFIER:RUN": # Test wheter the current script has a RUN FILE function
    text = str(get_file_text(str(tokens[2]).split(":")[1])).replace("{","{ \n")
else:
    text = text.replace("{","{ \n")
# Test wheater or not code contains a function.
if "PROCEDURE" in text: # There's a procedure!!! Use sublists
    proc_flag = True
    program_text = semi_parse_string(text)
else :
    program_text = semi_parse_string(add_else_to_if(text))[0]
    # Convert text to tokens for the else statement inserition
    result,error = run_program('<stdin>', program_text)
    if error:
        display_res(error.as_string())

if proc_flag:
    proc_flag = False
    for i in range(len(program_text)): # Run each part of the text seperatly
        if program_text[i].strip() == "":
            continue
        result,error = run_program('<stdin>', add_else_to_if(program_text[i]))
        if error:
            display_res(error.as_string())
            break
````

1.  **Initialization:**
      * `program_text = ""`: Initializes a variable to hold processed code segments.
      * `proc_flag = False`: A flag to indicate if the input `text` contains `PROCEDURE` definitions.
2.  **Empty Input Check:** If the `text` is empty or just whitespace, the function returns immediately.
3.  **Initial Tokenization for `RUN` Command Detection:**
      * `tokens = generate_tokens('<stdin>', text)`: The input `text` is tokenized to identify if it starts with a `RUN` command.
      * `if str(tokens[0]) == "IDENTIFIER:RUN":`: If the first token is `RUN`, it signifies that the `run` function itself was called as a result of a `RUN` command within the language (e.g., `RUN("my_file.txt")`).
          * `text = str(get_file_text(str(tokens[2]).split(":")[1])).replace("{","{ \n")`: In this case, the `text` variable is *overwritten* with the content of the file specified in the `RUN` command. The filename is extracted from the third token (assuming `RUN` is `tokens[0]`, `(` is `tokens[1]`, and the filename string is `tokens[2]`). Curly braces `{` are replaced with `{\n` to potentially aid subsequent parsing.
      * `else: text = text.replace("{","{ \n")`: If it's not a `RUN` command at the very beginning of the input, curly braces are still modified.
4.  **Procedure Detection and Semi-Parsing:**
      * `if "PROCEDURE" in text:`: Checks if the (potentially updated) `text` contains the keyword "PROCEDURE", indicating user-defined function definitions.
          * `proc_flag = True`: Sets the `proc_flag` to `True`.
          * `program_text = semi_parse_string(text)`: If `PROCEDURE` is found, `semi_parse_string` is called. This function is assumed to intelligently split the program text into sub-units, likely separating function definitions or complex blocks, preparing them for individual execution.
      * `else:` (No `PROCEDURE` found):
          * `program_text = semi_parse_string(add_else_to_if(text))[0]`: The `text` is first passed through `add_else_to_if` (which presumably modifies `if` statements to always have an `else` branch, or similar structural adjustments), then `semi_parse_string` is applied. It takes the *first* (and likely only) segment generated by `semi_parse_string`.
          * `result,error = run_program('<stdin>', program_text)`: The (single) segment of `program_text` is then passed to `run_program` for actual execution.
          * `if error: display_res(error.as_string())`: Any error from `run_program` is displayed.
5.  **Execution Loop for Procedures:**
      * `if proc_flag:`: If procedures were detected earlier, this block executes.
      * `for i in range(len(program_text)):`: Iterates through each segment generated by `semi_parse_string`.
      * `if program_text[i].strip() == "": continue`: Skips any empty segments.
      * `result,error = run_program('<stdin>', add_else_to_if(program_text[i]))`: Each segment is passed to `add_else_to_if` and then executed by `run_program`.
      * `if error: display_res(error.as_string()); break`: Any error during the execution of a segment is displayed, and the loop breaks, stopping further execution.

## `run_program(fn, text)`

**Purpose:** This function is the core execution pipeline of the interpreter. It takes program text (or pre-generated tokens) and orchestrates the three main phases: Lexing (tokenization), Parsing (AST generation), and Interpretation (execution).

**Parameters:**

  * `fn`: A string representing the filename or source identifier.
  * `text`: The string containing the code to be executed, or a list of pre-generated tokens.

**Explanation:**

```python
if not isinstance(text, list):
# Generate tokens
    lexer = Lexer(fn, text)
    tokens, error = lexer.make_tokens()
    #print(tokens) # <-- for debug purposes
    if error: return None, error
else:
    tokens = text

# Generate AST
parser = Parser(tokens)
ast = parser.parse()

if ast.error: return None, ast.error

# Run program
interpreter = Interpreter()
context = Context('<program>')
context.symbol_table = global_symbol_table
result = interpreter.visit(ast.node, context)

return result.value, result.error
```

1.  **Token Generation (Lexing):**
      * `if not isinstance(text, list):`: Checks if the `text` argument is raw code (a string) or already a list of tokens.
          * If it's a string:
              * `lexer = Lexer(fn, text)`: Creates a `Lexer` instance with the filename and code.
              * `tokens, error = lexer.make_tokens()`: Calls the lexer to generate a list of `tokens`.
              * `if error: return None, error`: If the lexer encounters an error (e.g., invalid character), it immediately returns the error.
          * `else: tokens = text`: If `text` is already a list, it's assumed to be pre-generated tokens.
2.  **AST Generation (Parsing):**
      * `parser = Parser(tokens)`: Creates a `Parser` instance with the generated `tokens`.
      * `ast = parser.parse()`: Calls the parser to build the Abstract Syntax Tree (AST). The `ast` object likely contains both the root node of the AST and any parsing errors.
      * `if ast.error: return None, ast.error`: If the parser encounters a syntax error, it immediately returns the error.
3.  **Program Execution (Interpretation):**
      * `interpreter = Interpreter()`: Creates an `Interpreter` instance.
      * `context = Context('<program>')`: Creates the initial execution `Context` for the entire program, named `'<program>'`.
      * `context.symbol_table = global_symbol_table`: Sets the symbol table of the program's context to the `global_symbol_table`. This ensures that top-level variables and functions are stored in and can access the global scope.
      * `result = interpreter.visit(ast.node, context)`: The core interpretation step. The `Interpreter`'s `visit` method is called with the root node of the AST and the program's initial context. This begins the recursive traversal and execution of the AST.
4.  **Return Result:**
      * `return result.value, result.error`: Returns the final `value` produced by the program's execution (if any) and any `error` that occurred during interpretation.

## `generate_tokens(fn, text)`

**Purpose:** A helper function that encapsulates the lexing process, returning only the tokens.

**Parameters:**

  * `fn`: The filename or source identifier.
  * `text`: The string containing the code.

**Explanation:**

```python
lexer = Lexer(fn, text)
tokens, error = lexer.make_tokens()
return tokens
```

1.  Creates a `Lexer` instance.
2.  Calls `lexer.make_tokens()` to generate tokens and potential errors.
3.  **Note:** This function *only* returns the `tokens` list, discarding any `error` produced by the lexer. This implies that `generate_tokens` is used in contexts where the presence of an error during tokenization is not immediately critical, or where the calling function (`run` in this case) intends to handle it differently (e.g., by re-lexing after file content replacement, as seen in `run`).

## `get_file_text(file_name)`

**Purpose:** Reads the entire content of a specified file. This is primarily used to load script content for the `RUN("")` command.

**Parameters:**

  * `file_name`: A string representing the path to the file.

**Explanation:**

```python
try:
    with open(file_name, "r") as f:
        script = f.read()
        return script
except Exception as e:
    return "Error"
```

1.  **File Reading:** Uses a `try-except` block to attempt opening the file in read mode (`"r"`) and reading its entire content into the `script` variable.
2.  **Error Handling:** If any `Exception` occurs during file operations (e.g., `FileNotFoundError`, permission errors), it catches the exception and returns the string `"Error"`. (A more robust implementation might return `None` or an error object to distinguish from valid file content.)

## `execute_run(self, exec_ctx)`

**Purpose:** This method (part of the `BuiltInFunction` class, as documented previously) defines the behavior of the built-in `RUN("")` command. It reads a specified file and then invokes the `run` utility function to execute its content.

**Parameters:**

  * `exec_ctx`: The execution context of the `RUN` command. Expected to contain a variable named `"fn"` (filename).

**Explanation:**

```python
fn = exec_ctx.symbol_table.get("fn")

if not isinstance(fn, String):
    return RTResult().failure(RTError(
        self.pos_start, self.pos_end,
        "Second argument must be string", # Refers to the internal argument passed to BuiltInFunction, which is the filename.
        exec_ctx
    ))

fn = fn.value

try:
    with open(fn, "r") as f:
        script = f.read()
except Exception as e:
    return RTResult().failure(RTError(
        self.pos_start, self.pos_end,
        f"Failed to load script \"{fn}\"\n" + str(e),
        exec_ctx
    ))

_, error = run(fn, script)

if error:
    return RTResult().failure(RTError(
        self.pos_start, self.pos_end,
        f"Failed to finish executing script \"{fn}\"\n" +
        error.as_string(),
        exec_ctx
    ))

return RTResult().success(Number.null)
```

1.  **Retrieve Filename:** Retrieves the `fn` argument (expected to be a `String` object) from the execution context's symbol table.
2.  **Type Check:** Validates that `fn` is indeed a `String`. If not, it returns an `RTError`.
3.  **Extract Value:** Extracts the actual Python string filename from the `String` object (`fn.value`).
4.  **Read File:**
      * Uses a `try-except` block to open and read the script content from the file specified by `fn`.
      * If any error occurs during file loading, it returns an `RTError` detailing the failure.
5.  **Execute Script:**
      * `_, error = run(fn, script)`: Calls the top-level `run` function (documented above) with the filename and the loaded script content. The return value is typically a result value and an error; here, only the `error` is captured.
6.  **Handle Execution Errors:** If the `run` function returns an `error` (meaning an error occurred during lexing, parsing, or interpretation of the loaded script), it wraps this error in an `RTError` and returns it.
7.  **Success:** If the script executes without errors, it returns `Number.null` as a successful result.

<!-- end list -->

```
```
