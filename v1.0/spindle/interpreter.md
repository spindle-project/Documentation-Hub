---
type: page
title: The Interpreter: From Tokens to Results
listed: true
slug: interpreter
description: 
index_title: The Interpreter: From Tokens to Results
hidden: 
keywords: 
tags: 
---

## Interpreter

The `Interpreter` class is responsible for executing the Abstract Syntax Tree (AST) generated by the parser. It "visits" each node in the AST and performs the corresponding actions, effectively running the program. This process is often referred to as "tree traversal" or "interpretation."

## Class: `Interpreter`

The `Interpreter` class utilizes a visitor pattern to handle different types of AST nodes. Each `visit_` method is tailored to execute the specific logic for that node type.

### `visit(self, node, context)`

**Purpose:** This is the central dispatch method that determines which specific `visit_` method to call based on the type of the `node` being processed.

**Parameters:**

- `node`: The current node in the Abstract Syntax Tree (AST) being visited. This node represents a specific construct in the programming language (e.g., a number, an operation, a variable assignment).
- `context`: The current execution context, which includes the symbol table (for storing variables and functions), the parent context, and other relevant runtime information.

**Explanation:**

1. **Method Name Construction:**
    method_name = f'visit_{type(node).__name__}'
    

This line dynamically constructs the name of the method to be called. For example, if `node` is an instance of a `NumberNode` class, `type(node).__name__` will be `'NumberNode'`, and `method_name` will become `'visit_NumberNode'`. This is a core part of the visitor pattern.

2. **Attribute Retrieval:**

    method = getattr(self, method_name, self.no_visit_method)

`getattr()` attempts to retrieve the method with the constructed `method_name` from the `Interpreter` instance (`self`). If a method with that name is not found, it defaults to `self.no_visit_method`.

3. **Method Invocation:**

    return method(node, context)

The retrieved method (either the specific `visit_` method or `no_visit_method`) is then called with the `node` and `context` as arguments, and its result is returned.

### `no_visit_method(self, node, context)`

**Purpose:** This method serves as a fallback or error handler if a specific `visit_` method is not defined for a particular node type.

**Parameters:**

- `node`: The AST node for which no specific visit method was found.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
raise Exception(f'No visit_{type(node).__name__} method defined')
{% /tab %}
{% /code %}

If this method is called, it means the interpreter does not know how to handle the given `node` type. It raises an `Exception` with an informative message, indicating which `visit_` method is missing. This is crucial for debugging during the development of the interpreter.

---

## Node Visit Methods

The following methods implement the interpretation logic for different types of AST nodes. All these methods are expected to return an `RTResult` object, which encapsulates the result of the execution (a value or an error) and control flow flags (like `should_return`, `loop_should_continue`, `loop_should_break`).

### `visit_Number(self, node, context)`

**Purpose:** Interprets a `Number` node, which represents a numerical literal.

**Parameters:**

- `node`: A `Number` node, containing a numerical value.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
return RTResult().success(
    Number(node.value).set_context(context).set_pos(node.pos_start, node.pos_end)
)
{% /tab %}
{% /code %}

This method directly takes the `value` from the `Number` node, wraps it in a `Number` object (presumably a custom value class that holds context and position), sets its context and position, and returns it as a successful `RTResult`.

### `visit_NumberNode(self, node, context)`

**Purpose:** Interprets a `NumberNode`, which represents a numerical literal parsed from a token.

**Parameters:**

- `node`: A `NumberNode`, containing a token (`node.tok`) with the numerical value.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
return RTResult().success(
    Number(node.tok.value).set_context(context).set_pos(node.pos_start, node.pos_end)
)
{% /tab %}
{% /code %}

Similar to `visit_Number`, but it extracts the numerical value from `node.tok.value`. This suggests that the AST might have different representations for numbers (e.g., `Number` for internal representation and `NumberNode` for parsed literals).

### `visit_StringNode(self, node, context)`

**Purpose:** Interprets a `StringNode`, which represents a string literal.

**Parameters:**

- `node`: A `StringNode`, containing a token (`node.tok`) with the string value.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
return RTResult().success(
    String(node.tok.value).set_context(context).set_pos(node.pos_start, node.pos_end)
)
{% /tab %}
{% /code %}

Extracts the string value from `node.tok.value`, wraps it in a `String` object (a custom value class), sets its context and position, and returns it as a successful `RTResult`.

### `visit_ListNode(self, node, context)`

**Purpose:** Interprets a `ListNode`, which represents a list (array) literal.

**Parameters:**

- `node`: A `ListNode`, containing a list of `element_nodes`.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
elements = []

for element_node in node.element_nodes:
    elements.append(res.register(self.visit(element_node, context)))
    if res.should_return(): return res

return res.success(
    List(elements).set_context(context).set_pos(node.pos_start, node.pos_end)
)
{% /tab %}
{% /code %}

1. Initializes an `RTResult` and an empty list `elements`.
2. Iterates through each `element_node` in the `node.element_nodes` list.
3. For each `element_node`, it recursively calls `self.visit()` to interpret the element's value. `res.register()` handles potential errors or control flow from the recursive call.
4. If a `should_return()` signal is received (e.g., an error or a `return` statement in a nested call), it immediately propagates the `RTResult`.
5. After all elements are evaluated, it creates a `List` object (custom value class) containing the evaluated `elements`, sets its context and position, and returns it as a successful `RTResult`.

### `visit_VarAccessNode(self, node, context)`

**Purpose:** Interprets a `VarAccessNode`, which represents accessing the value of a variable.

**Parameters:**

- `node`: A `VarAccessNode`, containing the token for the variable name (`node.var_name_tok`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
var_name = node.var_name_tok.value
value = context.symbol_table.get(var_name)

if not value:
    return res.failure(RTError(
        node.pos_start, node.pos_end,
        f"'{var_name}' is not defined",
        context
    ))
else:
    value = value.copy().set_pos(node.pos_start, node.pos_end).set_context(context)
    return res.success(value)
{% /tab %}
{% /code %}

1. Retrieves the variable name from `node.var_name_tok.value`.
2. Attempts to get the variable's `value` from the `context.symbol_table`.
3. **Error Handling:** If `value` is not found (meaning the variable is undefined), it returns an `RTError`.
4. **Success:** If the `value` is found, it creates a `copy` of the value (to prevent unintended modifications of the original), sets its position and context, and returns it as a successful `RTResult`.

### `visit_VarAssignNode(self, node, context)`

**Purpose:** Interprets a `VarAssignNode`, which represents assigning a value to a variable.

**Parameters:**

- `node`: A `VarAssignNode`, containing the variable name token (`node.var_name_tok`) and the node for the value to be assigned (`node.value_node`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
var_name = node.var_name_tok.value
value = res.register(self.visit(node.value_node, context))

if res.should_return(): return res

context.symbol_table.set(var_name, value)
return res.success(value)
{% /tab %}
{% /code %}

1. Retrieves the variable name.
2. Recursively `visits` the `node.value_node` to evaluate the expression that produces the value to be assigned. `res.register()` handles potential errors.
3. If an error or control flow signal is received during value evaluation, it propagates the `RTResult`.
4. **Assignment:** If successful, it sets the `var_name` to the evaluated `value` in the `context.symbol_table`.
5. Returns the assigned `value` as a successful `RTResult`.

### `visit_BinOpNode(self, node, context)`

**Purpose:** Interprets a `BinOpNode` (Binary Operation Node), handling arithmetic operations, comparisons, and logical operations.

**Parameters:**

- `node`: A `BinOpNode`, containing a left-hand side node (`node.left_node`), an operator token (`node.op_tok`), and a right-hand side node (`node.right_node`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
left = res.register(self.visit(node.left_node, context))
if res.should_return(): return res
right = res.register(self.visit(node.right_node, context))
if res.should_return(): return res

result, error = None, None # Initialize result and error

if node.op_tok.type == TT_PLUS:
    result, error = left.added_to(right)
elif node.op_tok.type == TT_MINUS:
    result, error = left.subbed_by(right)
# ... (similar elif blocks for TT_MUL, TT_DIV, TT_POW)
elif node.op_tok.type == TT_EE:
    result, error = left.get_comparison_eq(right)
# ... (similar elif blocks for TT_NE, TT_LT, TT_GT, TT_LTE, TT_GTE)
elif node.op_tok.matches(TT_KEYWORD, 'AND'):
    result, error = left.anded_by(right)
elif node.op_tok.matches(TT_KEYWORD, 'OR'):
    result, error = left.ored_by(right)
elif node.op_tok.matches(TT_KEYWORD, "NOT"): # This seems out of place for a binary op.
    result, error = left.notted()

if error:
    return res.failure(error)
else:
    return res.success(result.set_pos(node.pos_start, node.pos_end))
{% /tab %}
{% /code %}

1. **Operand Evaluation:** Recursively `visits` the `left_node` and `right_node` to get their evaluated values. `res.register()` handles potential errors.
2. **Operation Dispatch:** Based on the type of the `node.op_tok` (e.g., `TT_PLUS`, `TT_EE`, `TT_KEYWORD` for "AND"), it calls the corresponding method on the `left` operand (`added_to`, `subbed_by`, `get_comparison_eq`, `anded_by`, etc.). These methods (presumably defined on the `Number`, `String`, `List` value classes) perform the actual operation and return a `result` and an `error` if any.
3. **`NOT` Operator:** The `elif node.op_tok.matches(TT_KEYWORD, "NOT")` condition is somewhat unusual for a `BinOpNode`. `NOT` is typically a unary operator. This might indicate a structural design choice in the AST or an oversight.
4. **Error/Success Return:** If an `error` occurred during the operation, it returns an `RTResult` failure. Otherwise, it returns the `result` as a successful `RTResult`, ensuring its position is updated.

### `visit_UnaryOpNode(self, node, context)`

**Purpose:** Interprets a `UnaryOpNode` (Unary Operation Node), handling operations that apply to a single operand, such as negation or logical NOT.

**Parameters:**

- `node`: A `UnaryOpNode`, containing an operator token (`node.op_tok`) and the operand node (`node.node`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
number = res.register(self.visit(node.node, context))
if res.should_return(): return res

error = None

if node.op_tok.type == TT_MINUS:
    number, error = number.multed_by(Number(-1))
elif node.op_tok.matches(TT_KEYWORD, "NOT"):
    number, error = number.notted()

if error:
    return res.failure(error)
else:
    return res.success(number.set_pos(node.pos_start, node.pos_end))
{% /tab %}
{% /code %}

1. **Operand Evaluation:** Recursively `visits` the `node.node` to evaluate the operand's value. `res.register()` handles potential errors.
2. **Operation Dispatch:**

- If the operator is `TT_MINUS`, it effectively negates the number by multiplying it by `Number(-1)`.
- If the operator is the keyword "NOT", it calls the `notted()` method on the operand.

3. **Error/Success Return:** If an `error` occurred, it returns an `RTResult` failure. Otherwise, it returns the resulting `number` (or boolean value) as a successful `RTResult`, updating its position.

### `visit_IfNode(self, node, context)`

**Purpose:** Interprets an `IfNode`, handling conditional `if-elif-else` statements.

**Parameters:**

- `node`: An `IfNode`, containing a list of `cases` (condition-expression pairs) and an optional `else_case`.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
for condition, expr, should_return_null in node.cases:
    condition_value = res.register(self.visit(condition, context))
    if res.should_return(): return res

    if condition_value.is_true():
        expr_value = res.register(self.visit(expr, context))
        if res.should_return(): return res
        return res.success(Number.null if should_return_null else expr_value)

if node.else_case:
    expr, should_return_null = node.else_case
    else_value = res.register(self.visit(expr, context))
    if res.should_return(): return res
    return res.success(Number.null if should_return_null else else_value)

return res.success(Number.null)
{% /tab %}
{% /code %}

1. **Iterate Cases:** Loops through each `(condition, expr, should_return_null)` tuple in `node.cases` (representing `if` and `elif` blocks).
2. **Evaluate Condition:** For each case, it evaluates the `condition` by recursively `visiting` it. `res.register()` handles errors.
3. **Check Condition Truthiness:** `if condition_value.is_true():` checks if the evaluated condition is logically true.
4. **Execute Expression:** If the condition is true, it evaluates the `expr` (the body of the `if`/`elif` block). `res.register()` handles errors.
5. **Return Result:** Returns the `expr_value` as a successful `RTResult`. If `should_return_null` is true, it returns `Number.null` instead. If any nested evaluation triggers `res.should_return()`, it propagates that immediately.
6. **Handle Else Case:** If none of the `if`/`elif` conditions are met and an `else_case` exists, it evaluates the `else_case`'s expression and returns its value (or `Number.null`).
7. **Default Return:** If no conditions are met and there's no `else_case`, it returns `Number.null`.

### `visit_int(self, node, context)`

**Purpose:** A placeholder method.

**Parameters:**

- `node`: An integer value.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
pass
{% /tab %}
{% /code %}

This method is explicitly noted as doing nothing. The comment explains that when the interpreter encounters a number, it looks for `visit_int`. This implies a potential mismatch or a redundant method, as `visit_Number` and `visit_NumberNode` already handle numbers. This `visit_int` might be intended for direct Python `int` objects if they somehow enter the AST directly, which is less common in typical AST designs.

### `visit_ForNode(self, node, context)`

**Purpose:** Interprets a `ForNode`, representing a `for` loop (likely `REPEAT x TIMES`).

**Parameters:**

- `node`: A `ForNode`, containing information about the loop variable (`node.var_name_tok`), the end value (`node.end_value_node`), an optional step value (`node.step_value_node`), and the loop body (`node.body_node`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
elements = []

start_value = Number(0) # Initializes loop variable to 0
end_value = res.register(self.visit(node.end_value_node, context))
if res.should_return(): end_value = Number(1) # Handles error case for end_value

step_value = None
if node.step_value_node:
    step_value = res.register(self.visit(node.step_value_node, context))
    if res.should_return(): return res
else:
    step_value = Number(1) # Default step value is 1

i = start_value.value # Current loop counter (initialized to 0)

# Determine loop condition based on step value
if step_value.value >= 0:
    condition = lambda: int(str(i)) < int(str(end_value.value))
else:
    condition = lambda: i > end_value.value

while condition():
    context.symbol_table.set(node.var_name_tok.value, Number(i)) # Assign loop variable
    i = int(str(i))
    i += int(str(step_value.value)) # Increment loop variable

    value = (res.register(self.visit(node.body_node, context))) # Execute loop body
    if res.should_return() and res.loop_should_continue == False and res.loop_should_break == False: return res
    if res.loop_should_continue:
        continue # Handle 'continue' statement
    if res.loop_should_break:
        break # Handle 'break' statement
    elements.append(value) # Collect results from each iteration

return res.success(
    Number.null if node.should_return_null else
    List(elements).set_context(context).set_pos(node.pos_start, node.pos_end)
)
{% /tab %}
{% /code %}

1. **Initialization:** Initializes `start_value` to `Number(0)`. Evaluates `end_value` and `step_value` (defaulting to 1 if not provided).
2. **Loop Counter:** `i` is initialized with the starting value.
3. **Loop Condition:** A `lambda` function `condition` is created to determine when the loop should terminate, based on whether `step_value` is positive or negative. It converts values to `int(str(value))` which might be an unusual way to handle numeric comparisons if `Number` objects directly support comparison.
4. **Loop Execution:**

- Enters a `while` loop controlled by `condition()`.
- **Variable Assignment:** Sets the loop variable (`node.var_name_tok.value`) in the symbol table to the current `Number(i)`.
- **Increment/Decrement:** Updates `i` by adding the `step_value`.
- **Execute Body:** Recursively `visits` the `node.body_node` (the code inside the loop). `res.register()` handles errors.
- **Handle Control Flow:** Checks `res.loop_should_continue` and `res.loop_should_break` flags to implement `continue` and `break` statements.
- **Collect Results:** Appends the result of the body's execution to the `elements` list.

5. **Return Result:** Returns a `List` of the results from each iteration, or `Number.null` if `node.should_return_null` is true.

### `visit_WhileNode(self, node, context)`

**Purpose:** Interprets a `WhileNode`, representing a `while` loop.

**Parameters:**

- `node`: A `WhileNode`, containing the condition node (`node.condition_node`) and the loop body node (`node.body_node`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
elements = []

while True:
    condition = res.register(self.visit(node.condition_node, context))
    if res.should_return(): return res

    if not condition.is_true(): break # Exit loop if condition is false

    value = res.register(self.visit(node.body_node, context)) # Execute loop body
    if res.should_return() and res.loop_should_continue == False and res.loop_should_break == False: return res

    if res.loop_should_continue:
        continue # Handle 'continue'
    if res.loop_should_break:
        break # Handle 'break'
    elements.append(value) # Collect results

return res.success(
    Number.null if node.should_return_null else
    List(elements).set_context(context).set_pos(node.pos_start, node.pos_end)
)
{% /tab %}
{% /code %}

1. **Loop Execution:** Enters an infinite `while True` loop.
2. **Evaluate Condition:** Recursively `visits` `node.condition_node` to evaluate the loop condition.
3. **Check Condition Truthiness:** If `condition.is_true()` returns `False`, the loop `break`s.
4. **Execute Body:** If the condition is true, it executes `node.body_node`.
5. **Handle Control Flow:** Checks `res.loop_should_continue` and `res.loop_should_break` to implement `continue` and `break` statements.
6. **Collect Results:** Appends the result of the body's execution to `elements`.
7. **Return Result:** Returns a `List` of the results from each iteration, or `Number.null` if `node.should_return_null` is true.

### `visit_FuncDefNode(self, node, context)`

**Purpose:** Interprets a `FuncDefNode`, representing a function definition.

**Parameters:**

- `node`: A `FuncDefNode`, containing the function name token (`node.var_name_tok`), the body node (`node.body_node`), argument name tokens (`node.arg_name_toks`), and a flag for auto-return (`node.should_auto_return`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()

func_name = node.var_name_tok.value if node.var_name_tok else None
body_node = node.body_node
arg_names = [arg_name.value for arg_name in node.arg_name_toks]
func_value = Function(func_name, body_node, arg_names, node.should_auto_return).set_context(context).set_pos(node.pos_start, node.pos_end)

if node.var_name_tok:
    context.symbol_table.set(func_name, func_value)

return res.success(func_value)
{% /tab %}
{% /code %}

1. **Extract Function Details:** Retrieves the function name (if provided), the body node, and a list of argument names.
2. **Create Function Object:** Instantiates a `Function` object (a custom value class representing a callable function). This `Function` object encapsulates the `func_name`, `body_node`, `arg_names`, and `should_auto_return` flag. It also sets its context and position.
3. **Store in Symbol Table:** If `node.var_name_tok` exists (i.e., it's a named function, not an anonymous one), the `func_value` is stored in the `context.symbol_table` under its `func_name`.
4. Returns the created `func_value` as a successful `RTResult`.

### `visit_CallNode(self, node, context)`

**Purpose:** Interprets a `CallNode`, representing a function call.

**Parameters:**

- `node`: A `CallNode`, containing the node to be called (`node.node_to_call`) and a list of argument nodes (`node.arg_nodes`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
args = []

value_to_call = res.register(self.visit(node.node_to_call, context))
if res.should_return(): return res
value_to_call = value_to_call.copy().set_pos(node.pos_start, node.pos_end)

for arg_node in node.arg_nodes:
    args.append(res.register(self.visit(arg_node, context)))
    if res.should_return(): return res

return_value = res.register(value_to_call.execute(args))
if res.should_return(): return res
return_value = return_value.copy().set_pos(node.pos_start, node.pos_end).set_context(context)
return res.success(return_value)
{% /tab %}
{% /code %}

1. **Evaluate Function to Call:** Recursively `visits` `node.node_to_call` to get the actual function object to be invoked. `res.register()` handles errors.
2. **Evaluate Arguments:** Iterates through `node.arg_nodes`, recursively `visiting` each argument expression to evaluate its value. The evaluated arguments are collected in the `args` list. `res.register()` handles errors.
3. **Execute Function:** Calls the `execute()` method on the `value_to_call` (which should be a `Function` object or similar callable). This `execute()` method will handle setting up a new context for the function call, binding arguments, and evaluating the function's body.
4. **Handle Return Value:** The `return_value` from `value_to_call.execute()` is registered with `res`. If `res.should_return()` is true, it propagates the return.
5. Returns the `return_value` as a successful `RTResult`, ensuring its position and context are correctly set.

### `visit_ReturnNode(self, node, context)`

**Purpose:** Interprets a `ReturnNode`, representing a `return` statement in a function.

**Parameters:**

- `node`: A `ReturnNode`, containing an optional node for the value to return (`node.node_to_return`).
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
res = RTResult()
if node.node_to_return:
    value = res.register(self.visit(node.node_to_return, context))
    if res.should_return(): return res
else:
    value = Number.null # Default return value if no expression is provided
return res.success_return(value)
{% /tab %}
{% /code %}

1. **Evaluate Return Value:** If `node.node_to_return` exists, it recursively `visits` it to get the value to be returned. `res.register()` handles errors.
2. **Default Return Value:** If no `node_to_return` is specified (e.g., `return;`), the `value` is set to `Number.null`.
3. Returns the `value` using `res.success_return()`, which specifically signals that a function is returning and causes the `RTResult` to propagate up the call stack.

### `visit_ContinueNode(self, node, context)`

**Purpose:** Interprets a `ContinueNode`, representing a `continue` statement in a loop.

**Parameters:**

- `node`: A `ContinueNode`.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
return RTResult().success_continue()
{% /tab %}
{% /code %}

Returns an `RTResult` that specifically sets the `loop_should_continue` flag, signaling to the enclosing loop interpreter (e.g., `visit_ForNode`, `visit_WhileNode`) to skip the rest of the current iteration and proceed to the next.

### `visit_BreakNode(self, node, context)`

**Purpose:** Interprets a `BreakNode`, representing a `break` statement in a loop.

**Parameters:**

- `node`: A `BreakNode`.
- `context`: The current execution context.

**Explanation:**

{% code %}
{% tab language="python" %}
return RTResult().success_break()
{% /tab %}
{% /code %}

Returns an `RTResult` that specifically sets the `loop_should_break` flag, signaling to the enclosing loop interpreter to exit the loop entirely.